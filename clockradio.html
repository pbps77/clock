<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>시계 라디오</title>
<link rel="icon" type="image/png" sizes="32x32" href="./favicon-32.png">
<link rel="icon" type="image/png" sizes="192x192" href="./favicon-192.png">
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=IBM+Plex+Mono:wght@400;700&family=Roboto+Mono:wght@400;700&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: '7Segment';
      src: url('https://github.com/TheDudeThatCode/7-Segment/raw/master/7Segment.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    :root {
      --bg: #000000;
      --card: #0b1220;
      --accent: #60a5fa;
      --text: #e6eef8;
      color-scheme: light dark;
    }
    
    * { box-sizing: border-box; }
    
    html, body {
      height: 100%;
      margin: 0;
      font-family: 'JetBrains Mono', 'IBM Plex Mono', monospace;
    }
    
    body {
      background: #000000;
      color: var(--text);
      padding: 16px;
    }
    
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    
    /* Clock Styles - Digital LED Display */
    .clock-section {
      background: #1a1a1a;
      border: 3px solid #333;
      padding: 12px 32px;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 12px;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8), 0 8px 16px rgba(0, 0, 0, 0.5);
      font-family: 'JetBrains Mono', 'IBM Plex Mono', monospace;
    }
    
    .clock-section .date {
      font-size: 1.3rem;
      color: #00ff00;
      margin-bottom: 0;
      letter-spacing: 0px;
      text-shadow: 0 0 10px #00ff00, 0 0 20px rgba(0, 255, 0, 0.5);
      font-weight: 700;
    }
    
    .clock-section .time {
      font-size: 5rem;
      font-weight: 700;
      margin: 4px 0;
      color: #00ff00;
      letter-spacing: 2px;
      text-shadow: 0 0 15px #00ff00, 0 0 30px rgba(0, 255, 0, 0.6);
      font-family: 'Courier Prime', 'IBM Plex Mono', 'JetBrains Mono', monospace;
      font-weight: 700;
    }
    
    .clock-section .weekday {
      font-size: 1.3rem;
      color: #00ff00;
      letter-spacing: 0px;
      text-shadow: 0 0 8px #00ff00, 0 0 16px rgba(0, 255, 0, 0.4);
      font-weight: 700;
      margin-bottom: 0;
    }
    
    /* Radio Styles */
    .radio-section {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.04);
      padding: 20px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
    }
    
    .radio-section h2 {
      margin-top: 0;
      margin-bottom: 16px;
      font-size: 1.4rem;
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-bottom: 12px;
    }
    
    @media (min-width: 640px) {
      .grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }
    
    @media (min-width: 860px) {
      .grid {
        grid-template-columns: repeat(5, 1fr);
      }
    }
    
    button {
      border: 0;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.06);
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    button:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    
    button.active {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }
    
    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 14px 0 20px;
    }
    
    .row > input[type="text"] {
      flex: 1;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.03);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
    }
    
    .row > input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
    
    .now {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    
    .now .meta {
      min-width: 0;
      flex: 1;
    }
    
    .now .title {
      font-weight: 700;
      color: #00ff00;
      font-size: 1.1rem;
      text-shadow: 0 0 10px #00ff00, 0 0 20px rgba(0, 255, 0, 0.5);
      letter-spacing: 0px;
    }
    
    .now .url {
      font-size: 12px;
      color: #00ff00;
      opacity: 0.7;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 100%;
      text-shadow: 0 0 5px #00ff00;
    }
    
    audio {
      width: 100%;
      margin: 12px auto;
      max-width: 300px;
      display: block;
    }
    
    audio::-webkit-media-controls-volume-slider-container {
      display: none !important;
    }
    
    /* Volume Dial Styles */
    .volume-dial-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-top: 16px;
    }
    
    .volume-dial {
      width: 144px;
      height: 144px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2a2a2a, #1a1a1a);
      border: 3px solid #333;
      position: relative;
      cursor: pointer;
      box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.5);
    }
    
    .volume-dial::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      width: 10px;
      height: 61px;
      background: var(--accent);
      transform-origin: bottom center;
      transform: translateX(-50%) rotate(var(--dial-rotation, -135deg));
      border-radius: 2px;
      box-shadow: 0 0 8px var(--accent);
      transition: transform 0.1s ease;
    }
    
    .volume-dial::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 28px;
      height: 28px;
      background: #444;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      border: 2px solid #555;
    }
    
    .volume-level {
      font-size: 14px;
      color: var(--accent);
      font-weight: 700;
    }

    /* Channel Dial Styles */
    .channel-dial {
      width: 144px;
      height: 144px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #2a2a2a, #1a1a1a);
      border: 3px solid #333;
      position: relative;
      cursor: pointer;
      box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.5);
    }

    .channel-dial::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      width: 10px;
      height: 61px;
      background: #ff9500;
      transform-origin: bottom center;
      transform: translateX(-50%) rotate(var(--channel-dial-rotation, 0deg));
      border-radius: 2px;
      box-shadow: 0 0 8px #ff9500;
      transition: transform 0.1s ease;
    }

    .channel-dial::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 28px;
      height: 28px;
      background: #444;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      border: 2px solid #555;
    }

    .channel-label {
      font-size: 14px;
      color: #ff9500;
      font-weight: 700;
    }
    
    .tip {
      margin-top: 10px;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.6);
    }
    
    .error {
      color: #ff6b6b;
      font-weight: 600;
      margin-top: 8px;
    }
    
    .switch {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }
    
    .muted {
      color: rgba(255, 255, 255, 0.6);
      font-size: 13px;
    }
    
    @media (max-width: 420px) {
      .clock-section .time {
        font-size: 3rem;
      }
      .clock-section .date {
        font-size: 1.1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Clock Section -->
    <section class="clock-section" role="status" aria-live="polite">
      <div style="display: flex; justify-content: center; align-items: center; gap: 16px; margin-bottom: 8px;">
        <div class="date" id="date"></div>
        <div class="weekday" id="weekday"></div>
      </div>
      <div class="time" id="time"></div>
      
      <!-- Now Playing Info -->
      <div class="now" style="margin-top: 24px;">
        <div class="meta">
          <div class="title" id="nowTitle">-</div>
          <div class="url" id="nowUrl">-</div>
        </div>
        <label class="switch">
          <input type="checkbox" id="autoplay" checked style="display:none" aria-label="autoplay" />
          
        </label>
      </div>
    </section>

    <!-- Radio Section -->
    <section class="radio-section">
      
     <div class="grid" id="presetGrid">
     </div>

      <!-- Random and Stop buttons at the bottom -->
      <div class="grid" style="margin-top: 16px;">
        <button id="randomBtn">Random</button>
        <button id="stopBtn">Stop</button>  
      </div>

      <div style="display: flex; gap: 60px; align-items: center; justify-content: center; margin-top: 16px;">
 
            <div style="display: flex; flex-direction: column; align-items: center; width: 120px;">
              <div class="channel-dial" id="channelDial"></div>
              <div class="channel-label" id="channelLabel" style="min-width: 40px; text-align: center;">?</div>
            </div>
            
            <div style="display: flex; flex-direction: column; align-items: center; width: 120px;">
              <div class="volume-dial" id="volumeDial"></div>
              <div class="volume-level" id="volumeLevel" style="min-width: 40px; text-align: center;">50</div>
            </div>

      </div>
      <div style="display: flex;  align-items: center; margin-top: 16px;">
        <!-- Audio Player -->
        <audio id="player"  controls></audio>
  
      </div>

      <p class="tip" style="margin-top:12px">
        
       <div class="error" id="error" style="display:none"></div>
      </p>
      <p class="tip" style="margin-top:12px">
        ⚠️ 일부 스트림은 채널 선택시 지연이 발생할 수 있습니다.
      </p>

      <div class="row">
        <input id="customUrl" type="text" placeholder="직접 URL (예: https://.../playlist.m3u8 또는 http://.../stream.mp3)" />
        <button id="playCustom">재생</button>
      </div>

      
    </section>
  </div>

<script>
  // ========== Clock Logic ==========
  (function(){
    const $date = document.getElementById('date');
    const $time = document.getElementById('time');
    const $weekday = document.getElementById('weekday');

    const two = v => v.toString().padStart(2,'0');
    const weekdayNames = ['일요일','월요일','화요일','수요일','목요일','금요일','토요일'];

    function updateClock(){
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const day = now.getDate();
      const h = two(now.getHours());
      const m = two(now.getMinutes());
      const s = two(now.getSeconds());
      const wk = weekdayNames[now.getDay()];

      $date.textContent = `${year}년 ${month}월 ${two(day)}일`;
      $time.textContent = `${h}:${m}:${s}`;
      $weekday.textContent = wk;
    }

    updateClock();
    setInterval(updateClock, 1000);
  })();

  // ========== Radio Logic ==========
  const PRESETS = [
    { id: "kbs-1fm", name: "KBS 1FM-classic", api: "https://cfpwwwapi.kbs.co.kr/api/v1/landing/live/channel_code/24", resolveFrom: "kbs" },
    { id: "kbs-2fm", name: "KBS 2FM", api: "https://cfpwwwapi.kbs.co.kr/api/v1/landing/live/channel_code/25", resolveFrom: "kbs" },
    { id: "mbc-a_music", name: "MBC All That M", api: "https://sminiplay.imbc.com/aacplay.ashx?agent=webapp&channel=chm", resolveFrom: "mbc" },
    { id: "cbs-M", name: "CBS Music", url: "https://m-aac.cbs.co.kr/mweb_cbs939/_definst_/cbs939.stream/chunklist.m3u8", type: "application/vnd.apple.mpegurl" },
    { id: "cbs-standard", name: "CBS 표준FM", url: "https://m-aac.cbs.co.kr/mweb_cbs981/_definst_/cbs981.stream/chunklist.m3u8", type: "application/vnd.apple.mpegurl" },
    { id: "tbs-fm", name: "TBS FM", url: "https://cdnfm.tbs.seoul.kr/tbs/_definst_/tbs_fm_web_360.smil/playlist.m3u8", type: "application/vnd.apple.mpegurl" },
    { id: "tbs-efm", name: "TBS eFM", url: "https://cdnfm.tbs.seoul.kr/tbs/_definst_/tbs_efm_web_360.smil/playlist.m3u8", type: "application/vnd.apple.mpegurl" },
    { id: "ebs-fm", name: "EBS FM", url: "https://ebsonair.ebs.co.kr/fmradiofamilypc/familypc1m/playlist.m3u8", type: "application/vnd.apple.mpegurl" },
    //{ id: "gugak", name: "국악방송", url: "https://mgugaklive.nowcdn.co.kr/gugakradio/gugakradio.stream/playlist.m3u8", type: "application/vnd.apple.mpegurl" },
    { id: "afkn-daegu", name: "AFKN Daegu", url: "https://13743.live.streamtheworld.com/AFNP_DGUAAC.aac", type: "audio/aac" },
    { id: "afkn-tokyo", name: "AFN Tokyo", url: "https://25603.live.streamtheworld.com/AFNP_TKOAAC.aac", type: "audio/aac" },
    { id: "afn-01-pop", name: "AFN #1 Pop", url: "https://19273.live.streamtheworld.com/AFN01_S01AAC.aac", type: "audio/aac" },
    { id: "afn-jazz", name: "AFN Jazz", url: "https://19273.live.streamtheworld.com/AFN05_S01AAC.aac", type: "audio/aac" },
    { id: "afn-rnb", name: "AFN The Groove", url: "https://17843.live.streamtheworld.com/AFN03_S01AAC.aac", type: "audio/aac" },
    { id: "afkn-okinawa", name: "AFN GO Gravity", url: "https://18243.live.streamtheworld.com/AFN_GRVAAC.aac", type: "audio/aac" }
  ];

  const state = { current: null, hls: null, currentChannelIndex: 0, userPaused: false, userInteracted: false };

  
  const el = {
    grid: document.getElementById("presetGrid"),
    title: document.getElementById("nowTitle"),
    url: document.getElementById("nowUrl"),
    audio: document.getElementById("player"),
    status: document.getElementById("status"),
    error: document.getElementById("error"),
    autoplay: document.getElementById("autoplay"),
    customUrl: document.getElementById("customUrl"),
    playCustom: document.getElementById("playCustom"),
    volumeDial: document.getElementById("volumeDial"),
    volumeLevel: document.getElementById("volumeLevel"),
    randomBtn: document.getElementById("randomBtn"),
    channelDial: document.getElementById("channelDial"),
    channelLabel: document.getElementById("channelLabel")
  };

  function markUserInteracted(){ state.userInteracted = true; state.userPaused = false; }

  function isHlsUrl(u=""){ return /.m3u8(\?|$)/i.test(u); }
  function setError(msg){ el.error.textContent = msg || ""; el.error.style.display = msg ? "block" : "none"; }
  function setNow(meta, resolvedUrl){
    el.title.textContent = meta?.name || "-";
    el.url.textContent = resolvedUrl || meta?.url || meta?.api || "-";
    [...el.grid.querySelectorAll("button[data-id]")].forEach(b=>{
      if(b.dataset.id===meta?.id) b.classList.add("active"); else b.classList.remove("active");
    });
  }
  function cleanupHls(){ if(state.hls){ try{ state.hls.destroy(); }catch(e){} state.hls=null; } }
  function safePlay(){
    el.audio.muted = false;
    el.audio.play().catch(()=>{
      setError("자동재생이 차단되었습니다. 재생 버튼을 눌러주세요.");
    });
  }

  async function resolveKbsStream(apiUrl){
    const res = await fetch(apiUrl, { credentials: "omit" });
    if(!res.ok) throw new Error("KBS API 응답 오류: "+res.status);
    const data = await res.json();
    const url = data.channel_item?.[0]?.service_url;
    if(!url) throw new Error("KBS API에서 service_url을 찾을 수 없습니다.");
    return url;
  }

  async function resolveMbcStream(apiUrl){
    try {
      const res = await fetch(apiUrl, { 
        credentials: "omit",
        headers: { 
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
          "Accept": "*/*"
        }
      });
      
      if(!res.ok) throw new Error("MBC API 응답 오류: "+res.status);
      const body = await res.text();
      const url = body.trim();
      if(!url) throw new Error("MBC API에서 service_url을 찾을 수 없습니다.");
      return url;
    } catch(corsError) {
      console.warn("CORS 에러로 인해 프록시 서버를 사용합니다:", corsError.message);
      const PROXY = "https://cors-proxy-sek8.onrender.com/proxy?url=";
      const API = "https://sminiplay.imbc.com/aacplay.ashx?agent=webapp&channel=chm";
      const proxyUrl = PROXY + encodeURIComponent(API);

      const proxyRes = await fetch(proxyUrl, { credentials: "omit" });
      if(!proxyRes.ok) throw new Error("프록시 서버 응답 오류: "+proxyRes.status);
      
      const proxyBody = await proxyRes.text();
      const proxyUrlResult = proxyBody.trim();
      const idx = proxyUrlResult.indexOf("https");
      const result = idx !== -1 ? proxyUrlResult.substring(idx) : "";

      if(!result) throw new Error("프록시 서버에서 스트림 URL을 찾을 수 없습니다.");
      return result;
    }
  }
  
  async function playSource(meta){
    if(!meta) return;
    el.audio.muted = false;
    cleanupHls();
    setError(""); setNow(meta);
    let url = meta.url;

    if(!url && meta.api){
      try{
        if(meta.resolveFrom==="kbs") {url = await resolveKbsStream(meta.api); }
        else if(meta.resolveFrom==="mbc") {url = await resolveMbcStream(meta.api); }
        else throw new Error("알 수 없는 API 리졸버 유형입니다.");
      }catch(e){ setError(e.message || "API로부터 스트림 URL을 가져오지 못했습니다."); return; }
    }

    setNow(meta, url);
    const allowAutoPlay = !state.userPaused;
    el.audio.autoplay = allowAutoPlay;
    const onCanPlayOnce = ()=>{
      el.audio.removeEventListener("canplay", onCanPlayOnce);
      if(allowAutoPlay) safePlay();
    };
    el.audio.addEventListener("canplay", onCanPlayOnce);

    if(isHlsUrl(url)){
      if(el.audio.canPlayType("application/vnd.apple.mpegurl")){
        el.audio.src = url;
        if(allowAutoPlay) safePlay();
      }else if(Hls.isSupported()){
        state.hasAutoStarted = false;
        const hls = new Hls({ enableWorker: true, lowLatencyMode: true });
        state.hls = hls;
        hls.loadSource(url);
        hls.attachMedia(el.audio);
        hls.on(Hls.Events.ERROR, (_evt, data)=>{ if(data?.fatal) setError("HLS fatal: "+data.type+" / "+(data.details||"")); });
        if(allowAutoPlay){
          hls.on(Hls.Events.MANIFEST_PARSED, ()=>{
            if(!state.hasAutoStarted && !state.userPaused){
              state.hasAutoStarted = true;
              safePlay();
            }
          });
        }
      }else{
        setError("이 브라우저는 HLS를 재생할 수 없습니다. 다른 브라우저 또는 Safari를 사용해 보세요.");
        el.audio.removeAttribute("src");
      }
    }else{
      el.audio.src = url;
      if(allowAutoPlay) safePlay();
    }
    state.current = meta;
  }

  function stopPlayback(){
    const audio = el.audio;
    audio.pause();
    audio.muted = false;
    state.userPaused = true;
    if(state.hls){
      try{ if(typeof state.hls.stopLoad==='function') state.hls.stopLoad(); state.hls.destroy(); }catch(e){}
      state.hls=null;
    }
    audio.removeAttribute("src");
    audio.load();
    [...el.grid.querySelectorAll("button[data-id]")].forEach(b=> b.classList.remove("active"));
    el.title.textContent = "-";
    el.url.textContent = "-";
    state.current = null;
  }

  function initUI(){
    PRESETS.forEach((p, index)=>{
      const b=document.createElement("button");
      b.textContent=p.name; b.title=p.note||""; b.dataset.id=p.id;
      b.addEventListener("click", ()=> {
        markUserInteracted();
        playSource(p);
        state.currentChannelIndex = index;
        updateChannelDial();
      });
      el.grid.appendChild(b);
    });

    // 정지 버튼 이벤트
    document.getElementById("stopBtn").addEventListener("click", stopPlayback);

    el.playCustom.addEventListener("click", ()=>{
      const u=(el.customUrl.value||"").trim();
      if(!u) return;
      markUserInteracted();
      playSource({ id:"custom", name:"Custom", url:u });
    });

    // 초기 볼륨 설정 (스피커 ON 상태)
    el.audio.volume = 0.5;
    updateVolumeDial(50);

    // 볼륨 다이얼 컨트롤
    // 범위: 210도(7시) = 0%, 150도(5시) = 100%
    // 초기값: 50%
    let isDragging = false;
    
    let currStation =-1;

    function updateVolumeDial(volume) {
      // 210도(7시, 0%)에서 시계방향으로 회전하여 150도(5시, 100%)로
      // 실제로는 210도에서 270도(9시)를 거쳐 330도(11시)를 지나 30도(1시)를 거쳐 150도(5시)로 간다
      // 더 간단하게: 210도에서 시작해서 시계방향으로 300도 회전 (210 → 510 → 150)
      // 또는 -150도에서 시작해서 시계방향으로 300도 회전
      const rotation = 210 + (volume / 100) * 300;
      el.volumeDial.style.setProperty('--dial-rotation', rotation + 'deg');
      el.volumeLevel.textContent = volume;
      el.audio.volume = volume / 100;
    }
    
    function getVolumeFromAngle(x, y, rect) {
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // 각도 계산 (atan2는 수학 좌표계: 3시=0도, 6시=90도, 9시=180도, 12시=270도)
      let angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI);
      
      // 0~360도로 정규화
      if (angle < 0) {
        angle += 360;
      }
      
      // 시계 방향 기준으로 변환 (12시=0도, 3시=90도, 6시=180도, 9시=270도)
      angle = (angle + 90) % 360;
      
      // 범위: 210도(7시, 0%) ~ 510도(150도 = 5시, 100%)
      // 210도부터 시계방향으로 300도 범위
      let volume = null;
      
      // 0~150도 범위를 360~510도로 변환 (12시~5시 방향)
      if (angle <= 150) {
        angle += 360;
      }
      
      // 이제 210~510도 범위에서 계산
      if (angle >= 210 && angle <= 510) {
        volume = ((angle - 210) / 300) * 100;
      } else {
        // 150도 < angle < 210도는 범위 밖 (데드존)
        return null;
      }
      
      return Math.max(0, Math.min(100, Math.round(volume)));
    }
    
    el.volumeDial.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      const rect = el.volumeDial.getBoundingClientRect();
      const volume = getVolumeFromAngle(e.clientX, e.clientY, rect);
      if (volume !== null) updateVolumeDial(volume);
    });

    // Click event for immediate position update
    el.volumeDial.addEventListener('click', (e) => {
      e.preventDefault();
      const rect = el.volumeDial.getBoundingClientRect();
      const volume = getVolumeFromAngle(e.clientX, e.clientY, rect);
      if (volume !== null) updateVolumeDial(volume);
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const rect = el.volumeDial.getBoundingClientRect();
      const volume = getVolumeFromAngle(e.clientX, e.clientY, rect);
      if (volume !== null) updateVolumeDial(volume);
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    // Touch support
    el.volumeDial.addEventListener('touchstart', (e) => {
      isDragging = true;
      const rect = el.volumeDial.getBoundingClientRect();
      const touch = e.touches[0];
      const volume = getVolumeFromAngle(touch.clientX, touch.clientY, rect);
      if (volume !== null) updateVolumeDial(volume);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      const rect = el.volumeDial.getBoundingClientRect();
      const touch = e.touches[0];
      const volume = getVolumeFromAngle(touch.clientX, touch.clientY, rect);
      if (volume !== null) updateVolumeDial(volume);
    });
    
    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    // 랜덤 버튼 클릭 핸들러
    el.randomBtn.addEventListener('click', () => {
      if (PRESETS.length > 0) {
        const randomIndex = Math.floor(Math.random() * PRESETS.length);
        while (randomIndex === currStation ) {
          randomIndex = Math.floor(Math.random() * PRESETS.length);
        }
         currStation =randomIndex;
        const randomStation = PRESETS[randomIndex];
        markUserInteracted();
        state.currentChannelIndex = randomIndex;
       
        updateChannelDial();
        playSource(randomStation);
      }
    });

    // 채널 다이얼 기능
    function updateChannelDial() {
      // 210도(7시, 0번 채널)에서 510도(150도 = 5시, 마지막 채널)까지 300도 범위
      const rotation = 210 + (state.currentChannelIndex / PRESETS.length) * 300;
      el.channelDial.style.setProperty('--channel-dial-rotation', rotation + 'deg');
      el.channelLabel.textContent = `${state.currentChannelIndex + 1}/${PRESETS.length}`;
    }

    // 튜닝 소리 생성 함수 (랜덤화된 라디오 서치 톤)
    function playTuningSound() {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioContext.currentTime;

        // 약간씩 다른 길이/밴드/스윕으로 랜덤한 감각을 만든다.
        const duration = 0.26 + Math.random() * 0.14; // 0.26~0.40s
        const bandFreq = 750 + Math.random() * 900;   // 750~1650 Hz
        const bandQ = 0.9 + Math.random() * 1.2;      // 0.9~2.1
        const oscStart = 900 + Math.random() * 600;   // 900~1500 Hz
        const oscEnd = oscStart + 500 + Math.random() * 700; // +500~+1200
        const noiseStart = 0.14 + Math.random() * 0.1; // 0.14~0.24 gain

        // 화이트 노이즈 + 밴드패스
        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * duration, audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          const decay = 1 - i / data.length;
          data[i] = (Math.random() * 2 - 1) * 0.35 * decay;
        }

        const noise = audioContext.createBufferSource();
        noise.buffer = buffer;

        const bandpass = audioContext.createBiquadFilter();
        bandpass.type = "bandpass";
        bandpass.frequency.value = bandFreq;
        bandpass.Q.value = bandQ;

        const noiseGain = audioContext.createGain();
        noiseGain.gain.setValueAtTime(noiseStart, now);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + duration - 0.05);

        // 스테레오 살짝 움직임
        const panner = audioContext.createStereoPanner();
        panner.pan.setValueAtTime(-0.25 + Math.random() * 0.5, now);

        noise.connect(bandpass);
        bandpass.connect(noiseGain);
        noiseGain.connect(panner);
        panner.connect(audioContext.destination);

        // 얇은 스윕톤을 살짝 섞어 채널이 걸리는 느낌
        const osc = audioContext.createOscillator();
        osc.type = Math.random() > 0.5 ? "sine" : "triangle";
        osc.frequency.setValueAtTime(oscStart, now);
        osc.frequency.linearRampToValueAtTime(oscEnd, now + duration - 0.05);

        const oscGain = audioContext.createGain();
        oscGain.gain.setValueAtTime(0.04, now);
        oscGain.gain.exponentialRampToValueAtTime(0.003, now + duration - 0.05);

        osc.connect(oscGain);
        oscGain.connect(audioContext.destination);

        noise.start(now);
        noise.stop(now + duration);
        osc.start(now);
        osc.stop(now + duration - 0.05);
      } catch(e) {}
    }

    let isChannelDragging = false;
    let lastChannelIndex = state.currentChannelIndex;
    let channelDragStartX = 0;
    let channelDragStartY = 0;

    function getChannelFromAngle(x, y, rect) {
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // 각도 계산 (atan2는 수학 좌표계: 3시=0도, 6시=90도, 9시=180도, 12시=270도)
      let angle = Math.atan2(y - centerY, x - centerX) * (180 / Math.PI);
      
      // 시계 방향 기준으로 변환 (12시=0도, 3시=90도, 6시=180도, 9시=270도)
      angle = angle + 90;
      if (angle < 0) angle += 360;
      
      // 0~150도 범위를 360~510도로 변환 (12시~5시 방향)
      if (angle <= 150) {
        angle += 360;
      }
      
      // 범위: 210도(7시, 0번 채널) ~ 510도(150도 = 5시, 마지막 채널)
      if (angle < 210 || angle > 510) {
        return null; // 범위 밖이면 null 반환
      }
      
      // 210~510도 범위를 0~PRESETS.length로 변환
      const channelIndex = Math.round(((angle - 210) / 300) * PRESETS.length) % PRESETS.length;
      return channelIndex;
    }

    el.channelDial.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isChannelDragging = true;
      markUserInteracted();
      lastChannelIndex = state.currentChannelIndex;
      channelDragStartX = e.clientX;
      channelDragStartY = e.clientY;
      
      // 클릭 시 즉시 해당 채널로 이동
      const rect = el.channelDial.getBoundingClientRect();
      const channel = getChannelFromAngle(e.clientX, e.clientY, rect);
      if (channel !== null && channel !== state.currentChannelIndex) {
        state.currentChannelIndex = channel;
        updateChannelDial();
        playSource(PRESETS[channel]);
        el.audio.play().catch(()=>{});
      }
    });

    // Click event for immediate channel change
    el.channelDial.addEventListener('click', (e) => {
      e.preventDefault();
      markUserInteracted();
      const rect = el.channelDial.getBoundingClientRect();
      const channel = getChannelFromAngle(e.clientX, e.clientY, rect);
      if (channel !== null && channel !== state.currentChannelIndex) {
        state.currentChannelIndex = channel;
        updateChannelDial();
        playSource(PRESETS[channel]);
        el.audio.play().catch(()=>{});
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (!isChannelDragging) return;
      const rect = el.channelDial.getBoundingClientRect();
      const channel = getChannelFromAngle(e.clientX, e.clientY, rect);
      if (channel !== null && channel !== state.currentChannelIndex) {
        state.currentChannelIndex = channel;
        updateChannelDial();
        playTuningSound();
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (!isChannelDragging) return;
      isChannelDragging = false;
      el.audio.muted = false;
      
      // 방향 감지: X축 이동에 따라 다음/이전 채널로
      const deltaX = e.clientX - channelDragStartX;
      const deltaY = e.clientY - channelDragStartY;

      let targetChannel = state.currentChannelIndex;
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
        targetChannel = deltaX > 0 
          ? (state.currentChannelIndex + 1) % PRESETS.length
          : (state.currentChannelIndex - 1 + PRESETS.length) % PRESETS.length;
      }

      state.currentChannelIndex = targetChannel;
      updateChannelDial();
      playSource(PRESETS[targetChannel]);
      el.audio.play().catch(()=>{});
    });

    el.channelDial.addEventListener('touchstart', (e) => {
      isChannelDragging = true;
      markUserInteracted();
      lastChannelIndex = state.currentChannelIndex;
      const touch = e.touches[0];
      channelDragStartX = touch.clientX;
      channelDragStartY = touch.clientY;
      
      // 터치 시 즉시 해당 채널로 이동
      const rect = el.channelDial.getBoundingClientRect();
      const channel = getChannelFromAngle(touch.clientX, touch.clientY, rect);
      if (channel !== null && channel !== state.currentChannelIndex) {
        state.currentChannelIndex = channel;
        updateChannelDial();
        playSource(PRESETS[channel]);
        el.audio.play().catch(()=>{});
      }
      e.preventDefault();
    });

    document.addEventListener('touchmove', (e) => {
      if (!isChannelDragging) return;
      const rect = el.channelDial.getBoundingClientRect();
      const touch = e.touches[0];
      const channel = getChannelFromAngle(touch.clientX, touch.clientY, rect);
      if (channel !== null && channel !== state.currentChannelIndex) {
        state.currentChannelIndex = channel;
        updateChannelDial();
        playTuningSound();
      }
    });

    document.addEventListener('touchend', (e) => {
      if (!isChannelDragging) return;
      isChannelDragging = false;
      el.audio.muted = false;
      
      // 방향 감지: X축 이동에 따라 다음/이전 채널로
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - channelDragStartX;
      const deltaY = touch.clientY - channelDragStartY;
      
      let targetChannel = state.currentChannelIndex;
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
        targetChannel = deltaX > 0 
          ? (state.currentChannelIndex + 1) % PRESETS.length
          : (state.currentChannelIndex - 1 + PRESETS.length) % PRESETS.length;
      }

      state.currentChannelIndex = targetChannel;
      updateChannelDial();
      playSource(PRESETS[targetChannel]);
      el.audio.play().catch(()=>{});
    });

    // 초기 로딩 시 자동 선택 해제
    // playSource(PRESETS[0]);
    
    // 사용자 상호작용 후 자동재생 활성화 (브라우저 정책)
    document.addEventListener('click', function enableAutoplay() {
      markUserInteracted();
      if(el.audio.paused){
        el.audio.muted = false;
        el.audio.play().catch(()=>{});
      }
      document.removeEventListener('click', enableAutoplay);
    }, { once: true });
  }

  window.addEventListener("DOMContentLoaded", initUI);
</script>
</body>
</html>
